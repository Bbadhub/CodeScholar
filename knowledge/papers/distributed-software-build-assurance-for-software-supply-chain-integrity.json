{
  "summary": "The paper presents a distributed software build assurance scheme that detects modifications in the software supply chain, enhancing security against malicious injections. Engineers should care because it leverages blockchain technology to provide a decentralized verification process, significantly improving efficiency and integrity in software builds.",
  "key_contribution": "A distributed software build assurance scheme utilizing blockchain to verify software integrity across the supply chain.",
  "problem_type": "software supply chain integrity verification",
  "problem_description": "The need to secure software development against malicious modifications and injections throughout the software supply chain.",
  "domain": "Cybersecurity",
  "sub_domain": "Software Supply Chain Security",
  "technique_name": "Distributed Software Build Assurance",
  "technique_category": "framework",
  "technique_type": "novel",
  "method": {
    "approach": "The method uses reproducible builds and a software bill of materials (SBOM) to ensure the integrity of software artifacts. It generates a proof based on the software artifacts and compares it with a reference proof stored on a blockchain.",
    "algorithm_steps": [
      "1. User downloads source code (s) and dependencies.",
      "2. User compiles the source code to generate build output (b) and SBOM documentation (d).",
      "3. User constructs a Merkle tree using s, b, and d to generate proof (p).",
      "4. User retrieves reference proof (p') from the blockchain.",
      "5. User compares p with p'.",
      "6. If p equals p', the software artifacts are verified as unmodified."
    ],
    "input": "Source code files (s), build output (b), SBOM documentation (d)",
    "output": "Proof of integrity (p) for the software artifacts",
    "key_parameters": [
      "hash_function: SHA-256",
      "Merkle_tree: constructed from s, b, d",
      "blockchain: permissioned with proof-of-authority consensus"
    ],
    "complexity": "Not stated"
  },
  "benchmarks": {
    "datasets": [
      "Ethereum software (Archanes v1.13.4)"
    ],
    "metrics": [
      "verification time: approximately 1 second overhead",
      "performance gain: 2-3 orders of magnitude quicker than centralized server"
    ],
    "baselines": [
      "Centralized server approach for software build assurance"
    ],
    "improvement": "Significant performance gains over centralized server approaches"
  },
  "concepts": [
    "blockchain",
    "Merkle tree",
    "reproducible build",
    "software bill of materials",
    "cryptographic hash function"
  ],
  "use_this_when": [
    "You need to verify the integrity of software builds in a decentralized manner.",
    "You are working with open-source software projects that require assurance against malicious modifications.",
    "You want to implement a secure software supply chain process."
  ],
  "dont_use_when": [
    "The software artifacts are not reproducible across different environments.",
    "You require real-time verification with a centralized authority.",
    "The overhead of generating proofs is unacceptable for your application."
  ],
  "implementation_guide": {
    "data_structures": [
      "Merkle tree",
      "blockchain ledger"
    ],
    "dependencies": [
      "Ethereum Smart Contract",
      "cryptographic libraries for SHA-256"
    ],
    "pseudocode_hint": "proof = MerkleTree(hash(s), hash(b), hash(d))",
    "gotchas": [
      "Ensure reproducible builds are supported in your environment.",
      "Watch for discrepancies in software artifacts across different machines.",
      "Be aware of the overhead introduced by proof generation."
    ]
  },
  "connects_to": [
    "reproducible builds",
    "software bill of materials",
    "blockchain technology",
    "cryptographic hash functions"
  ],
  "prerequisites": [
    "Understanding of blockchain technology",
    "Knowledge of cryptographic hash functions",
    "Familiarity with software build processes"
  ],
  "limitations": [
    "Requires reproducible builds to function effectively.",
    "Performance may vary based on blockchain network conditions.",
    "Not suitable for environments without consistent build conditions."
  ],
  "open_questions": [
    "How can this approach be generalized to other software applications?",
    "What are the implications of using different consensus protocols on performance?"
  ]
}